import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage
from sklearn.decomposition import PCA
from sklearn.metrics import adjusted_rand_score, adjusted_mutual_info_score, fowlkes_mallows_score
from validation.clustering_metrics import purity_score
from validation.scs_metric import scs_metric

from common.extrema import find_extrema_2D
from common.neighbourhood import get_valid_neighbours8
from dataset_parsing.simulations.simulations_dataset import get_dataset_simulation
from som_graph_ops import expand_clusters, create_graph, get_labels, expand_unlabeled
from som_utils import som_train_save_load, normalize_data

from visualization.som_plot import map_plot
from visualization import scatter_plot as sp


def plot_segm(distance_map, maxs):

    plt.figure(figsize=(10, 10))
    plt.pcolor(distance_map.T,cmap='bone')
    plt.colorbar()
    plt.title("Segmentation of U-matrix")

    test = np.stack(np.where(maxs == True))
    for max in test.T:
        plt.scatter(max[0], max[1], c='r')

def run_som_approach(X, y, data_type, data_number):
    # Hyperparams
    pn = 2*int(np.sqrt(5 * np.sqrt(X.shape[0])))
    som_shape = (pn, pn)
    sigma = 12
    lr = 0.01
    iterations = len(X) * 5

    model_name = f"./models/SOM_{data_type}{data_number}_params_shape({som_shape[0]}-{som_shape[1]})_sigma{sigma}_lr{lr:.0e}_iter{iterations}.p"
    som = som_train_save_load(model_name, X, som_shape, sigma, lr, iterations)

    distance_map = np.array(som.distance_map())
    distance_map = normalize_data(distance_map)

    som_winners = [som.winner(xx) for xx in X]
    map_plot("GT on U-matrix", som_winners, som_shape, labels=y, map_type="distance", map=distance_map)
    map_plot("U-matrix", som_winners, som_shape, labels=None, map_type="distance", map=distance_map)

    mins, maxs_map = find_extrema_2D((distance_map * 255).astype(int), 1, "or")


    x = np.copy(distance_map)
    maxs = np.zeros_like(distance_map)
    for i in range(1, x.shape[0]-1):
        for j in range(1, x.shape[1]-1):
            if x[i, j] > THRESHOLD / 100 * np.amax(x):
                if x[i-1, j-1] < x[i, j] and x[i, j] > x[i+1, j+1]:
                    maxs[i, j] = 1

                if x[i-1, j+1] < x[i, j] and x[i, j] > x[i+1, j-1]:
                    maxs[i, j] = 1

                if x[i-1, j] < x[i, j] and x[i, j] > x[i+1, j]:
                    maxs[i, j] = 1

                if x[i, j-1] < x[i, j] and x[i, j] > x[i, j+1]:
                    maxs[i, j] = 1


    maxs_map[x < THRESHOLD / 100 * np.amax(x)] = False


    maxs = np.logical_or(maxs.astype(bool), maxs_map)

    for i in range(0, maxs.shape[0]):
        for j in range(0, maxs.shape[1]):
            if maxs[i, j] == True:
                neighbors = get_valid_neighbours8(np.array([i, j]), maxs.shape)
                flag = True
                for neigh in neighbors:
                    if maxs[tuple(neigh)] == True:
                        flag = False

                if flag == True:
                    maxs[i, j] = False

    iters = 3
    maxs_closed = ndimage.binary_closing(maxs, structure=np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]]), iterations=iters)

    maxs = np.logical_or(maxs_closed, maxs)

    plot_segm(distance_map, maxs)

    distance_map[maxs] = 1


    locations = np.array([[som.winner(d)[0], som.winner(d)[1]] for d in X], dtype=int)

    graph = create_graph(locations, distance_map, 1)
    expand_clusters(graph)

    labels = get_labels(graph, locations)

    pca_2d = PCA(n_components=2)
    X_test = pca_2d.fit_transform(X)
    sp.plot(f'GT on {data_type}{data_number}', X_test, y, marker='o')
    plt.show()
    sp.plot(f'SOBM unexpanded on {data_type}{data_number}', X_test, labels, marker='o')
    plt.show()

    graph = expand_unlabeled(graph, som.distance_map().shape)

    labels = get_labels(graph, locations)

    map_plot("Proposed approach on U-matrix", som_winners, som_shape, labels=labels, map_type="distance", map=som.distance_map())
    sp.plot(f'Proposed approach on {data_type}{data_number}', X_test, labels, marker='o')
    plt.show()

    print(adjusted_rand_score(y, labels))
    print(adjusted_mutual_info_score(y, labels))
    print(fowlkes_mallows_score(y, labels))
    print(purity_score(y, labels))
    print(scs_metric(np.array(y).astype(int), np.array(labels).astype(int)))



if __name__ == "__main__":
    THRESHOLD = 5
    SIM = 9
    X, y = get_dataset_simulation(SIM)
    run_som_approach(X, y, "sim", SIM)

