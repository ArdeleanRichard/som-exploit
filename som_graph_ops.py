import random

import networkx as nx
import numpy as np

from common.neighbourhood import get_valid_neighbours, get_neighbours, get_valid_neighbours4



def create_graph(spikes, distance_map, THR):
    """
    (2) Graph creation
    :param spikes: matrix - the points of the dataset

    :returns g: graph -  the graph
    """
    g = nx.Graph()

    for spike in spikes:
        string_spike = spike.tostring()
        if string_spike in g:
            g.nodes[string_spike]['count'] += 1
        else:
            g.add_node(string_spike, count=1, label=-1, distance=distance_map[spike[0], spike[1]])

    # print(distance_map)
    for node in list(g.nodes):
        if g.nodes[node]['distance'] < THR:
            neighbours = get_valid_neighbours4(np.fromstring(node, dtype=int), distance_map.shape)

            for neighbour in neighbours:
                string_neighbour = neighbour.tostring()
                if string_neighbour in g and g.nodes[string_neighbour]['distance'] < THR:
                    g.add_edge(node, string_neighbour)

    return g



def expand_clusters(graph, label=0):
    """
    (4) Expansion of Centroids in the graph
    :param graph: graph - the graph
    :param label: integer - the label of the current center

    """

    # This is done for each expansion in order to be able to disambiguate
    for node in list(graph.nodes):
        graph.nodes[node]['visited'] = 0

    subgraphs = [graph.subgraph(c).copy() for c in nx.connected_components(graph)]
    # print(len(subgraphs))

    for subgraph in subgraphs:
        if len(list(subgraph.nodes)) > 1:
            random_node = random.choice(list(subgraph.nodes))

            expansionQueue = []

            if subgraph.nodes[random_node]['label'] == -1:
                expansionQueue.append(random_node)
                subgraph.nodes[random_node]['label'] = label
                graph.nodes[random_node]['label'] = label

            subgraph.nodes[random_node]['visited'] = 1

            while expansionQueue:
                current = expansionQueue.pop(0)

                neighbours = list(subgraph.neighbors(current))

                for neighbour in neighbours:
                    if subgraph.nodes[neighbour]['visited'] == 0:
                        subgraph.nodes[neighbour]['visited'] = 1
                        graph.nodes[neighbour]['visited'] = 1
                        if subgraph.nodes[neighbour]['label'] == -1:
                            subgraph.nodes[neighbour]['label'] = label
                            graph.nodes[neighbour]['label'] = label
                            expansionQueue.append(neighbour)
            label += 1


def expand_unlabeled(graph, shape):
    labels = []
    for node in list(graph.nodes):
        labels.append(graph.nodes[node]['label'])

    unique_labels = np.unique(np.array(labels))

    cluster_centers = []
    nr_nodes = []
    for unique_label in unique_labels[1:]:
        nodes = []
        cluster_nodes = 0
        for node in list(graph.nodes):
            if graph.nodes[node]['label'] == unique_label:
                nodes.append(np.fromstring(node, dtype=int))
                cluster_nodes+=1
        nodes = np.array(nodes)
        cluster_centers.append(np.mean(nodes, axis=0))
        nr_nodes.append(cluster_nodes)


    count = get_unlabeled(graph)
    last_count = -1

    while(last_count != count):
        last_count = count
        graph = expand_neighbours_limited(graph, shape)
        count = get_unlabeled(graph)

    count = get_unlabeled(graph)
    last_count = -1
    while (last_count != count):
        last_count = count

        graph = expand_neighbours(graph)
        count = get_unlabeled(graph)

    return graph


def expand_neighbours(graph):
    test_graph = graph.copy()
    for string_node in list(test_graph.nodes):
        if test_graph.nodes[string_node]['label'] == -1: #and test_graph.nodes[string_node]['count'] != 0:
            neigh_labels = []
            node = np.fromstring(string_node, dtype=int)
            neighbours = get_neighbours(node)

            for neighbour in neighbours:
                string_neighbour = neighbour.tostring()
                if string_neighbour in test_graph and graph.nodes[string_neighbour]['label'] != -1:
                    neigh_labels.append(graph.nodes[string_neighbour]['label'])
            neigh_labels = np.array(neigh_labels)

            if neigh_labels.size > 0:
                if np.all(neigh_labels == neigh_labels[0]):
                    test_graph.nodes[string_node]['label'] = neigh_labels[0]

    return test_graph


def expand_neighbours_limited(graph, shape):
    test_graph = graph.copy()
    for string_node in list(test_graph.nodes):
        if test_graph.nodes[string_node]['label'] == -1: #and test_graph.nodes[string_node]['count'] != 0:
            neigh_labels = []
            node = np.fromstring(string_node, dtype=int)
            neighbours = get_valid_neighbours(node, shape)


            test = True
            for neighbour in neighbours:
                string_neighbour = neighbour.tostring()
                if not string_neighbour in test_graph:
                    test = False

            if test == True:
                for neighbour in neighbours:
                    string_neighbour = neighbour.tostring()
                    if string_neighbour in test_graph and graph.nodes[string_neighbour]['label'] != -1:
                        neigh_labels.append(graph.nodes[string_neighbour]['label'])
            neigh_labels = np.array(neigh_labels)

            if neigh_labels.size > 0:
                if np.all(neigh_labels == neigh_labels[0]):
                    test_graph.nodes[string_node]['label'] = neigh_labels[0]
    return test_graph



def get_unlabeled(graph):
    count = 0
    for string_node in list(graph.nodes):
        if graph.nodes[string_node]['label'] == -1:
            count+=1
    return count


def get_labels(graph, spikes):
    """
    (5) Dechunkification - Fifth and last step of ISBM
    Transforms the labels of the chunks/nodes into the labels of each of the points
    :param graph: graph - the graph of chunks
    :param spikes: matrix - contains the dataset of samples

    :returns labels: vector - the labels of the points
    """
    labels = []

    for spike in spikes:
        string_spike = spike.tostring()
        labels.append(graph.nodes[string_spike]['label'])

    return labels