import matplotlib
import numpy as np
from matplotlib import pyplot as plt, gridspec
import plotly.graph_objects as go

from visualization.label_map import MARKERS, COLORS


def map_plot(title, som_winners, som_shape, labels, map_type="", map=None):
    # To visualize the result of the training we can plot the distance map (U-Matrix)
    # using a pseudocolor where the neurons of the maps are displayed as an array of cells and the color
    # represents the (weights) distance from the neighbour neurons.
    # On top of the pseudo color we can add markers that repesent the samples mapped in the specific cells:

    # label_color = np.array([cs.LABEL_COLOR_MAP[l] for l in labels])

    plt.figure(figsize=(10, 10))
    plt.title(title)

    if len(som_shape) == 2:
        if map is not None:
            if map_type == 'count':
                type = np.copy(map).T
                plt.pcolor(type, cmap='bone')  # plotting the distance map as background
            if map_type == 'distance':
                type = np.copy(map).T
                plt.pcolor(type, cmap='bone')  # plotting the distance map as background
            plt.colorbar()

        for cnt, som_winner in enumerate(som_winners):
            # print(w) # (18, 14) ; (5, 6)
            if labels is None:
                plt.plot(som_winner[0] + .5, som_winner[1] + .5)
            else:
                plt.plot(som_winner[0] + .5, som_winner[1] + .5,
                         MARKERS[labels[cnt]], markerfacecolor='None',
                         markeredgecolor=COLORS[labels[cnt]],
                         markersize=12, markeredgewidth=2)
    elif len(som_shape) == 3:
        ax = plt.axes(projection='3d')

        for cnt, som_winner in enumerate(som_winners):
            if labels is None:
                ax.plot3D(som_winner[0] + .5, som_winner[1] + .5, som_winner[2] + .5,)
            else:
                ax.plot3D(som_winner[0] + .5, som_winner[1] + .5, som_winner[2] + .5,
                         MARKERS[labels[cnt]], markerfacecolor='None',
                         markeredgecolor=COLORS[labels[cnt]],
                         markersize=12, markeredgewidth=2)

    plt.show()


def distributionPlot(som, data, target):
    colors = []
    label_names = {}
    for idx in np.unique(target):
        colors.append(f'C{idx}')
        label_names[idx] = f'C{idx}'

    # To have an overview of how the samples are distributed across the map a scatter chart can be used where each dot represents the coordinates of the winning neuron.
    # A random offset is added to avoid overlaps between points within the same cell.
    plt.figure(figsize=(10, 10))
    plt.pcolor(som.distance_map().T, cmap='bone_r', alpha=.2)
    plt.colorbar()

    w_x, w_y = zip(*[som.winner(d) for d in data])
    w_x = np.array(w_x)
    w_y = np.array(w_y)

    for c in np.unique(target):
        idx_target = target == c
        plt.scatter(w_x[idx_target] + .5 + (np.random.rand(np.sum(idx_target)) - .5) * .8,
                    w_y[idx_target] + .5 + (np.random.rand(np.sum(idx_target)) - .5) * .8,
                    s=50, c=colors[c - 1], label=label_names[c])
    plt.legend(loc='upper right')
    plt.grid()
    plt.savefig('./feature_extraction/SOM/minisom/som_seed.png')
    plt.show()


def seedMap(data, target, som, som_shape):
    colors = []
    label_names = {}
    for idx in np.unique(target):
        colors.append(f'C{idx}')
        label_names[idx] = f'C{idx}'

    # To have an idea of which neurons of the map are activated more often we can create another
    # pseudocolor plot that reflects the activation frequencies:
    plt.figure(figsize=(7, 7))
    frequencies = som.activation_response(data)
    plt.pcolor(frequencies.T, cmap='Blues')
    plt.colorbar()
    plt.show()

    # When dealing with a supervised problem, one can visualize the proportion of
    # samples per class falling in a specific neuron using a pie chart per neuron:
    labels_map = som.labels_map(data, [label_names[t] for t in target])

    fig = plt.figure(figsize=(10, 10))
    the_grid = gridspec.GridSpec(som_shape[0], som_shape[1], fig)
    for position in labels_map.keys():
        label_fracs = [labels_map[position][l] for l in label_names.values()]
        plt.subplot(the_grid[som_shape[0] - 1 - position[1], position[0]], aspect=1)
        patches, texts = plt.pie(label_fracs)

    plt.legend(patches, label_names.values(), bbox_to_anchor=(3.5, 6.5), ncol=3)
    plt.savefig('./feature_extraction/SOM/minisom/som_seed_pies.png')
    plt.show()


def plotStarburstMap(som):
    ### Starburst Gradient visualization
    # This visualization can be used to find similaraties between neurons resp. between the samples that are represented. the black lines follow the maximum gradient between nodes,
    # the stars separate regions of neurons with smaller distance towards each other from others.
    boner_rgb = []
    norm = matplotlib.colors.Normalize(vmin=0, vmax=255)
    bone_r_cmap = matplotlib.cm.get_cmap('bone_r')

    bone_r = matplotlib_cmap_to_plotly(bone_r_cmap, 255)

    layout = go.Layout(title='starburstMap')
    fig = go.Figure(layout=layout)
    fig.add_trace(go.Heatmap(z=som.distance_map().T, colorscale=bone_r))
    shapes=[]

    for row in np.arange(som.distance_map().shape[0]):
        for col in np.arange(som.distance_map().shape[1]):
            cx,cy = findInternalNode(row, col, som.distance_map().T)
            shape=go.layout.Shape(
                    type="line",
                    x0=row,
                    y0=col,
                    x1=cx,
                    y1=cy,
                    line=dict(
                        color="Black",
                        width=1
                    )
                )
            shapes=np.append(shapes, shape)

    fig.update_layout(shapes=shapes.tolist(),
        width=500,
        height=500)
    fig.show()


def findMin(x, y, umat):
    newxmin = max(0,x-1)
    newxmax = min(umat.shape[0],x+2)
    newymin = max(0,y-1)
    newymax = min(umat.shape[1],y+2)
    minx, miny = np.where(umat[newxmin:newxmax,newymin:newymax] == umat[newxmin:newxmax,newymin:newymax].min())
    return newxmin+minx[0], newymin+miny[0]


def findInternalNode(x, y, umat):
    minx, miny = findMin(x,y,umat)
    if (minx == x and miny == y):
        cx = minx
        cy = miny
    else:
        cx,cy = findInternalNode(minx,miny,umat)
    return cx, cy


def matplotlib_cmap_to_plotly(cmap, entries):
    h = 1.0/(entries-1)
    colorscale = []

    for k in range(entries):
        C = (np.array(cmap(k*h)[:3])*255)
        colorscale.append([k*h, 'rgb'+str((C[0], C[1], C[2]))])

    return colorscale