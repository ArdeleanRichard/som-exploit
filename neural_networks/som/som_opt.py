# from minisom import MiniSom
from hyperopt import fmin, tpe, hp, Trials, STATUS_OK

from neural_networks.som.Minisom2D import MiniSom2D
from neural_networks.som.Minisom3D import MiniSom3D


def create_som(X, som_shape, sigma, lr):
    # Initialization and training
    # neighborhood_function : string, optional (default='gaussian')
    #     Function that weights the neighborhood of a position in the map.
    #     Possible values: 'gaussian', 'mexican_hat', 'bubble', 'triangle'
    #
    # activation_distance : string, callable optional (default='euclidean')
    #     Distance used to activate the map.
    #     Possible values: 'euclidean', 'cosine', 'manhattan', 'chebyshev'
    #
    # topology : string, optional (default='rectangular')
    #     Topology of the map.
    #     Possible values: 'rectangular', 'hexagonal'
    if len(som_shape) == 2:
        som = MiniSom2D(x=som_shape[0], y=som_shape[1], input_len=X.shape[1],
                      sigma=sigma, learning_rate=lr,
                      neighborhood_function='gaussian',
                      activation_distance='euclidean',
                      topology='rectangular',
                      random_seed=0)
    elif len(som_shape) == 3:
        som = MiniSom3D(x=som_shape[0], y=som_shape[1], z=som_shape[2], input_len=X.shape[1],
                      sigma=sigma, learning_rate=lr,
                      neighborhood_function='gaussian',
                      activation_distance='euclidean',
                      topology='rectangular',
                      random_seed=0)

    return som


def train_som(som, X, iterations):
    som.pca_weights_init(X)
    som.train(data=X, num_iteration=iterations, verbose=True)  # random training

    return som


def optimize_som(X, som_shape, max_lr, iterations, opt_with_train=False):
    optimizing_space = {
        'sig': hp.uniform("sig", 0.0001, som_shape[0] / 2.01),  # sigma cant be more than pn/2
        'lrate': hp.uniform("lrate", 0.0001, max_lr)
    }

    def optimize_som_fn(space):
        sig = space['sig']
        lrate = space['lrate']

        som = create_som(X, som_shape, sig, lrate)
        if opt_with_train:
            som = train_som(som, X, iterations)
        # locations = np.array([[som.winner(d)[0], som.winner(d)[1]] for d in X])
        # error = metrics.silhouette_score(locations, y, metric='euclidean')
        error = som.quantization_error(X)

        return {'loss': error, 'status': STATUS_OK}

    trials = Trials()
    best = fmin(
        fn=optimize_som_fn,
        space=optimizing_space,
        algo=tpe.suggest,
        max_evals=100,
        trials=trials
    )

    print(f'best {best}')
    #
    # for i, trial in enumerate(trials.trials[:2]):
    #     print(i, trial)

    return best